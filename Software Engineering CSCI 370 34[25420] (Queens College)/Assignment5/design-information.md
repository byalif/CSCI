### Alif Rahi / CS370

# `UML design information`

- In my application, I kept it simple with only 3 entities. Speaking from experience, when I create fullstack projects I always make sure my associations make sense. You don't need a million tables for an ecommerce type of database. A simple cart table titled `[List_items]` in my DB is responsible for holding all the cart items in the entire store's history. You simply filter out the carts for a specific user by using the functions I implemented in my UML.

- The select, insert, update and delete methods can all be derived from the DB by using attributes I listed in my UML as well as the functions I implemented. We need the following attributes from my UML; `user_id` (To specify who), `list_type` (To specify which List you want to add to) and the `item_id` (To specify which item) and this will take care of manipulating a users cart. If you wanted to clear an entire cart or clear all the checked items without deleting it, you simply leave out the `item_id` because your applying this query to ALL the items. Something you would NEED an `item_id` for is counting the quantity of an item in a cart. For this feature, I used a derived attribute. We can do this by querying the db for all rows that have the specified `user_id`, `item_id` and `list_type` and then storing the count of rows from that query as the result in an integer variable.

- We manipulate the tables and rows by using methods like these with specific input parameters. For example, when searching for a specific item in the store we can call another method such as `findItemsByName()` or `findItemsByType()` and the parameters in those functions will be something the user on the Front end will type in the search bar. The request to the server will trigger the `[Items]` entity/Table to query for the desired rows from the tables we need and fetch them back to the user in the front end to be satisfied. On the front end we can use onChange handlers to send /get requests to the DB each time a user types inside the search bar.

- In many cases we can also associate tables with one another because some results might need foreign keys involved. For the CRUD operations of search, create, update and delete on a users List we will need to join a few tables. You can see that we will need to join the `[User]` table, the `[Item]` table and the `[List_Items]` table to find our specified result. If we don’t pass in the `user_id` parameter, we might update all the users carts. If we don’t pass in the `item_id`, how will we know which item to update? And if you don't add the `list_type` parameter, you might update all your lists. Which you don’t want because you may have multiple Lists/carts for different purposes.
